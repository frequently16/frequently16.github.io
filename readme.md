# 整个项目的通信结构

![](./readmeresource/communication.png)

# 描述各个组件的工作
下面描述从 用户点击“开始匹配”到网页显示蛇的移动期间前后端各个组件的工作流程。

用户在网页端可以选择亲自出马或者自己的bot来参与对战。点击开始匹配后，参与匹配的用户id和botId传入后端微服务(backend)。后端微服务将这些匹配信息传给匹配系统(Matching System)。

匹配系统匹配成功后再将匹配结果传给后端微服务。后端微服务立即随机生成一张游戏地图并将匹配成功的信息以及游戏地图发送给前端。

如果用户使用bot参加游戏，后端微服务将bot代码以及战况发送给bot代码运行的微服务(Botrunning System)，并等待这段代码的返回值。如果用户亲自出马，后端微服务将等待用户的下一步输入，以操纵蛇的移动方向。

bot代码运行的微服务可能会接收到多个bot代码，它将这些对象存放在一个线程安全的list中。再

不论如何，后端将收到蛇的下一步移动方向，然后更新游戏地图以判断是否有玩家输掉了比赛，如果有则将结果返回给前端，如果没有则将两条蛇的下一步移动方向同时发送给前端。

前端收到消息后再根据情况渲染不同的前端组件(ResultBoard或GameMap)。

# 公开页面与授权页面的实现
## SessionID模式（弃用）
用户登录后传给后端用户名和密码，后端将它们和数据库中的用户数据进行比对。如果用户名和密码都正确，后端就给前端发送SessionID，同时这个SessionID后端也会保留一份，同时也会记录这个SessionID对应的用户id。

发给前端的SessionID会保存在浏览器的cookie里面。以后用户要访问授权页面时都会把cookie里面的SessionID发送给后端。

后端如果通过这个SessionID能够找到对应的用户是谁，说明这个SessionID是有效的。那么后端就会将用户相应的信息提取到上下文中。这样用户就能正常访问那些授权页面了。

## Jwt-token模式（本项目使用）
**Jwt-token的定义**：用户拥有自己的userId信息，服务器拥有一段只有服务器内部才能查看的密钥。将这两段字符串拼接在一起并通过加密函数生成一段加密后的字符串。服务器将userId和这段加密后的字符串拼接在一起，这就是一个Jwt-token。

用户登录后，服务器就会生成一段只属于这个用户的Jwt-token，并将它发给用户，自己不保存。

这样，每次用户要访问授权页面时，服务器都接收一遍用户传来的userId和Jwt-token。将这个userId和自己的密钥拼接起来再通过加密函数生成加密后的字符串。将这个加密后的字符串与Jwt-token的第二段字符串进行比较。如果这两段字符串匹配，后端就将用户信息提取到上下文。这样用户就能正常访问那些授权页面了。

### Jwt-token模式的优点
1. 后端服务器无需存储用户的登录状态。如果有多个服务器，那么就无需像SessionID一样每个服务器复制一份SessionID；
2. 不依赖于cookie存储Jwt-token，因此可以实现移动端登录。



